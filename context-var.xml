<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="internalfunc-contextvar">
        <info>
            <title>Контекстные переменные</title>
        </info>
    
        <section xml:id="internalfunc-contextvar-current_connection">
            <info>
                <title>CURRENT_CONNECTION</title>
                <keywordset>
                    <keyword>CURRENT_CONNECTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CURRENT_CONNECTION</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_CONNECTION                      
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>BIGINT</para>
            </formalpara>

            <para>Переменная CURRENT_CONNECTION хранит уникальный идентификатор текущего соединения.
                Значение переменной хранится в странице заголовка базы и сбрасывается после restore.
                Переменная увеличивается на единицу при каждом последующем соединении с базой данных
                (соединения также могут быть внутренними вызванными самим ядром). Следовательно,
                переменная показывает количество подключений произошедших к базе после её
                восстановления (или после её создания). </para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_CONNECTION</title>
                        <para><programlisting language="sql">
SELECT CURRENT_CONNECTION FROM RDB$DATABASE                  
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_transaction"
                        >CURRENT_TRANSACTION</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-current_date">
            <info>
                <title>CURRENT_DATE</title>
                <keywordset>
                    <keyword>CURRENT_DATE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CURRENT_DATE</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_DATE                      
                        </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>DATE</para>
            </formalpara>

            <para>Переменная CURRENT_DATE возвращает текущую дату сервера. </para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_DATE</title>
                        <para><programlisting language="sql">
CREATE DOMAIN DDATE_DNN AS
DATE DEFAULT CURRENT_DATE NOT NULL                
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-today">'TODAY'</link>, <link
                        linkend="internalfunc-contextvar-current_timestamp"
                    >CURRENT_TIMESTAMP</link>, <link linkend="internalfunc-contextvar-current_time"
                        >CURRENT_TIME</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-current_role">
            <info>
                <title>CURRENT_ROLE</title>
                <keywordset>
                    <keyword>CURRENT_ROLE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CURRENT_ROLE</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_ROLE                      
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>VARCHAR(31)</para>
            </formalpara>

            <para>Контекстная переменная CURRENT_ROLE служит для определения роли, с которой
                произошло подключение к базе данных. В случае если произошло подключение без
                указания роли, переменная принимает значение NONE.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_ROLE</title>
                        <para><programlisting language="sql">
SELECT CURRENT_ROLE FROM RDB$DATABASE               
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <note>
                <para>Такое же значение можно будет получить и в результате выполнения запроса:
                    <programlisting language="sql">
SELECT RDB$GET_CONTEXT ('SYSTEM', 'CURRENT_ROLE')
FROM RDB$DATABASE;
                    </programlisting>
                </para>
            </note>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-func-context-getcontext">RDB$GET_CONTEXT</link>.
                </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-current_time">
            <info>
                <title>CURRENT_TIME</title>
                <keywordset>
                    <keyword>CURRENT_TIME</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CURRENT_TIME</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_TIME [(<replaceable>&lt;precision&gt;</replaceable>)]

<replaceable>&lt;precision&gt;</replaceable> ::= 0 | 1 | 2 | 3                        
                        </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры контекстной переменной CURRENT_TIME</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. Значение по умолчанию 0. Не поддерживается в
                                        ESQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>TIME</para>
            </formalpara>

            <para>Переменная CURRENT_TIME возвращает текущее время сервера. Точность определяет,
                сколько учитывать знаков после запятой в долях секунды. Точность по умолчанию равна
                0.</para>

            <note>
                <para>В блоке кода PSQL (процедура, триггер, исполняемый блок) значение CURRENT_TIME
                    не меняется по мере выполнения. При вызове вложенного кода, значение также не
                    изменится и будет равно значению в коде самого верхнего уровня. Для определения
                    реального времени используйте другие переменные, например 'NOW' (с полным
                    приведением типа данных). </para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_TIME</title>
                        <para><programlisting language="sql">
SELECT CURRENT_TIME(2) FROM RDB$DATABASE;
-- результат будет (например) 23:35:33.1200            
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <warning>
                <para>Firebird 4.0 будет поддерживать часовые пояса.</para>
                <para>В рамках этой поддержки будет возникать несовместимость с выражением
                        <code>CURRENT_TIME</code> предыдущих версий.</para>
                <para>В Firebird 4.0 выражение <code>CURRENT_TIME</code> будет возвращать тип данных
                        <code>TIME WITH TIME ZONE</code>.</para>
                <para>Для того чтобы ваши запросы были совместимы с кодом баз данных будующих
                    версий, начиная с Firebird 3.0.4 вы можете использовать выражение
                        <code>LOCALTIME</code>. В 3.0 <code>LOCALTIME</code> является синонимом
                        <code>CURRENT_TIME</code>.</para>
                <para>В Firebird 4.0 <code>LOCALTIME</code> будет продолжать работать точно так же
                    как сейчас, в то время как <code>CURRENT_TIME</code> будет возвращать другой тип
                    данных.</para>

                <para>Вам не следует начинать использовать <code>LOCALTIME</code>, если можете
                    произвести даунгрейд вашей базы данных до версии 3.0.3 или другой более младшей
                    версии, поскольку старые версии Firebird не смогут распознать новые
                    выражения.</para>
            </warning>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-localtime">LOCALTIME</link>, <link
                        linkend="internalfunc-contextvar-now">'NOW'</link>, <link
                        linkend="internalfunc-contextvar-current_timestamp"
                    >CURRENT_TIMESTAMP</link>, <link linkend="internalfunc-contextvar-current_date"
                        >CURRENT_DATE</link>. </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-current_timestamp">
            <info>
                <title>CURRENT_TIMESTAMP</title>
                <keywordset>
                    <keyword>CURRENT_TIMESTAMP</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CURRENT_TIMESTAMP</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_TIMESTAMP [(<replaceable>&lt;precision&gt;</replaceable>)]

<replaceable>&lt;precision&gt;</replaceable> ::= 0 | 1 | 2 | 3                        
                        </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры контекстной переменной CURRENT_TIMESTAMP</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. Значение по умолчанию 3. Не поддерживается в
                                        ESQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>TIMESTAMP</para>
            </formalpara>

            <para>Переменная CURRENT_TIMESTAMP возвращает текущую дату и время сервера. Точность
                определяет, сколько учитывать знаков после запятой в долях секунды. Точность по
                умолчанию равна 3.</para>
            <note>
                <para>В блоке кода PSQL (процедура, триггер, исполняемый блок) значение
                    CURRENT_TIMESTAMP не меняется по мере выполнения. При вызове вложенного кода,
                    значение также не изменится и будет равно значению в коде самого верхнего
                    уровня. Для определения реального времени используйте другие переменные,
                    например 'NOW' (с полным приведением типа данных). </para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_TIMESTAMP</title>
                        <para><programlisting language="sql">
SELECT CURRENT_TIMESTAMP(2) FROM RDB$DATABASE;
-- результат будет (например) 02.03.2014 23:35:33.1200            
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <warning>
                <para>Firebird 4.0 будет поддерживать часовые пояса.</para>
                <para>В рамках этой поддержки будет возникать несовместимость с выражением
                        <code>CURRENT_TIMESTAMP</code> предыдущих версий.</para>
                <para>В Firebird 4.0 выражение <code>CURRENT_TIMESTAMP</code> будет возвращать тип
                    данных <code>TIMESTAMP WITH TIME ZONE</code>.</para>
                <para>Для того чтобы ваши запросы были совместимы с кодом баз данных будующих
                    версий, начиная с Firebird 3.0.4 вы можете использовать выражение
                        <code>LOCALTIMESTAMP</code>. В 3.0 <code>LOCALTIMESTAMP</code> является
                    синонимом <code>CURRENT_TIMESTAMP</code>.</para>
                <para>В Firebird 4.0 <code>LOCALTIMESTAMP</code> будет продолжать работать точно так
                    же как сейчас, в то время как <code>CURRENT_TIMESTAMP</code> будет возвращать
                    другой тип данных.</para>

                <para>Вам не следует начинать использовать <code>LOCALTIMESTAMP</code>, если можете
                    произвести даунгрейд вашей базы данных до версии 3.0.3 или другой более младшей
                    версии, поскольку старые версии Firebird не смогут распознать новые
                    выражения.</para>
            </warning>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-localtimestamp">LOCALTIMESTAMP</link>,
                        <link linkend="internalfunc-contextvar-now">'NOW'</link>, <link
                        linkend="internalfunc-contextvar-current_time">CURRENT_TIME</link>, <link
                        linkend="internalfunc-contextvar-current_date">CURRENT_DATE</link>. </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-current_transaction">
            <info>
                <title>CURRENT_TRANSACTION</title>
                <keywordset>
                    <keyword>CURRENT_TRANSACTION</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CURRENT_TRANSACTION</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_TRANSACTION                      
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>BIGINT</para>
            </formalpara>

            <para>Переменная CURRENT_TRANSACTION содержит уникальный номер текущей транзакции. </para>
            <para>Значение CURRENT_TRANSACTION хранится в странице заголовка базы данных и
                сбрасывается в 0 после восстановления (или создания базы). Оно увеличивается при
                старте новой транзакции.</para>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_TRANSACTION</title>
                        <para><programlisting language="sql">
SELECT CURRENT_TRANSACTION FROM RDB$DATABASE;

NEW.TRANS_ID = CURRENT_TRANSACTION;
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_connection"
                        >CURRENT_CONNECTION</link>, <link
                        linkend="internalfunc-func-context-getcontext">RDB$GET_CONTEXT</link>.
                </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-current_user">
            <info>
                <title>CURRENT_USER</title>
                <keywordset>
                    <keyword>CURRENT_USER</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CURRENT_USER</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CURRENT_USER                      
                        </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>VARCHAR(31)</para>
            </formalpara>

            <para>Переменная CURRENT_USER содержит имя текущего подключенного пользователя базы
                данных. </para>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной CURRENT_USER</title>
                        <para><programlisting language="sql">
NEW.ADDED_BY = CURRENT_USER;
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-user">USER</link>, <link
                        linkend="internalfunc-contextvar-current_role">CURRENT_ROLE</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-deleting">
            <info>
                <title>DELETING</title>
                <keywordset>
                    <keyword>DELETING</keyword>
                </keywordset>
            </info>

            <indexterm><primary>DELETING</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
DELETING                      
                        </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>BOOLEAN</para>
            </formalpara>

            <para>Контекстная переменная DELETING доступна только в коде табличных триггеров.
                Используется в триггерах на несколько типов событий и показывает, что триггер
                сработал при выполнении операции DELETE.</para>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной DELETING</title>
                        <para><programlisting language="sql">
...
IF (DELETING) THEN
BEGIN
  INSERT INTO REMOVED_CARS (
    ID, MAKE, MODEL, REMOVED)
  VALUES (
    OLD.ID, OLD.MAKE, OLD.MODEL, CURRENT_TIMESTAMP);
END
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-inserting">INSERTING</link>, <link
                        linkend="internalfunc-contextvar-updating">UPDATING</link>. </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-gdscode">
            <info>
                <title>GDSCODE</title>
                <keywordset>
                    <keyword>GDSCODE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>GDSCODE</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
GDSCODE                      
                        </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>INTEGER</para>
            </formalpara>

            <para>В блоке обработки ошибок &quot;WHEN ... DO&quot; контекстная переменная GDSCODE
                содержит числовое представление текущего кода ошибки Firebird. До версии Firebird
                2.0 GDSCODE можно было получить только с использованием конструкции WHEN GDSCODE.
                Теперь эту контекстную переменную можно также использовать в блоках WHEN ANY, WHEN
                SQLCODE и WHEN EXCEPTION при условии, что код ошибки соответствует коду ошибки
                Firebird. Вне обработчика ошибок GDSCODE всегда равен 0. Вне PSQL GDSCODE не
                существует вообще. </para>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной GDSCODE</title>
                        <para><programlisting language="sql">
...
WHEN GDSCODE GRANT_OBJ_NOTFOUND,
     GDSCODE GRANT_FLD_NOTFOUND,
     GDSCODE GRANT_NOPRIV,
     GDSCODE GRANT_NOPRIV_ON_BASE
DO
BEGIN
  EXECUTE PROCEDURE LOG_GRANT_ERROR(GDSCODE);
  EXIT;
END
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <note>
                <para>Обратите внимание, пожалуйста: после, WHEN GDSCODE вы должны использовать
                    символьные имена — такие, как <replaceable>grant_obj_notfound</replaceable> и
                    т.д. Но контекстная переменная GDSCODE - целое число. Для сравнения его с
                    определённой ошибкой вы должны использовать числовое значение, например,
                    335544551 для <replaceable>grant_obj_notfound</replaceable>.</para>
            </note>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-sqlcode">SQLCODE</link>, <link
                        linkend="internalfunc-contextvar-sqlstate">SQLSTATE</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-inserting">
            <info>
                <title>INSERTING</title>
                <keywordset>
                    <keyword>INSERTING</keyword>
                </keywordset>
            </info>

            <indexterm><primary>INSERTING</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
INSERTING                      
                    </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>BOOLEAN</para>
            </formalpara>

            <para>Контекстная переменная INSERTING доступна только коде табличных триггеров.
                Используется в триггерах на несколько типов событий и показывает, что триггер
                сработал при выполнении операции INSERT. </para>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной INSERTING</title>
                        <para><programlisting language="sql">
...
IF (INSERTING OR UPDATING) THEN
BEGIN
  IF (NEW.SERIAL_NUM IS NULL) THEN
    NEW.SERIAL_NUM = GEN_ID (GEN_SERIALS, 1);
END
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-updating">UPDATING</link>, <link
                        linkend="internalfunc-contextvar-deleting">DELETING</link>. </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-localtime">
            <info>
                <title>LOCALTIME</title>
                <keywordset>
                    <keyword>LOCALTIME</keyword>
                </keywordset>
            </info>

            <indexterm><primary>LOCALTIME</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
LOCALTIME [(<replaceable>&lt;precision&gt;</replaceable>)]

<replaceable>&lt;precision&gt;</replaceable> ::= 0 | 1 | 2 | 3                        
                        </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры контекстной переменной LOCALTIME</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. Значение по умолчанию 0. Не поддерживается в
                                        ESQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>TIME</para>
            </formalpara>

            <para>Переменная LOCALTIME возвращает текущее время сервера. Точность определяет,
                сколько учитывать знаков после запятой в долях секунды. Точность по умолчанию равна
                0.</para>

            <note>
                <para>В блоке кода PSQL (процедура, триггер, исполняемый блок) значение LOCALTIME не
                    меняется по мере выполнения. При вызове вложенного кода, значение также не
                    изменится и будет равно значению в коде самого верхнего уровня. Для определения
                    реального времени используйте другие переменные, например 'NOW' (с полным
                    приведением типа данных). </para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной LOCALTIME</title>
                        <para><programlisting language="sql">
SELECT LOCALTIME(2) FROM RDB$DATABASE;
-- результат будет (например) 23:35:33.1200            
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <warning>
                <para>Firebird 4.0 будет поддерживать часовые пояса.</para>
                <para>В рамках этой поддержки будет возникать несовместимость с выражением
                        <code>CURRENT_TIME</code> предыдущих версий.</para>
                <para>В Firebird 4.0 выражение <code>CURRENT_TIME</code> будет возвращать тип данных
                        <code>TIME WITH TIME ZONE</code>.</para>
                <para>Для того чтобы ваши запросы были совместимы с кодом баз данных будующих
                    версий, начиная с Firebird 3.0.4 вы можете использовать выражение
                        <code>LOCALTIME</code>. В 3.0 <code>LOCALTIME</code> является синонимом
                        <code>CURRENT_TIME</code>.</para>
                <para>В Firebird 4.0 <code>LOCALTIME</code> будет продолжать работать точно так же
                    как сейчас, в то время как <code>CURRENT_TIME</code> будет возвращать другой тип
                    данных.</para>

                <para>Вам не следует начинать использовать <code>LOCALTIME</code>, если можете
                    произвести даунгрейд вашей базы данных до версии 3.0.3 или другой более младшей
                    версии, поскольку старые версии Firebird не смогут распознать новые
                    выражения.</para>
            </warning>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_time">CURRENT_TIME</link>, <link
                        linkend="internalfunc-contextvar-now">'NOW'</link>, <link
                        linkend="internalfunc-contextvar-current_timestamp"
                    >CURRENT_TIMESTAMP</link>, <link linkend="internalfunc-contextvar-current_date"
                        >CURRENT_DATE</link>. </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-localtimestamp">
            <info>
                <title>LOCALTIMESTAMP</title>
                <keywordset>
                    <keyword>LOCALTIMESTAMP</keyword>
                </keywordset>
            </info>

            <indexterm><primary>LOCALTIMESTAMP</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
LOCALTIMESTAMP [(<replaceable>&lt;precision&gt;</replaceable>)]

<replaceable>&lt;precision&gt;</replaceable> ::= 0 | 1 | 2 | 3                        
                        </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры контекстной переменной LOCALTIMESTAMP</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. Значение по умолчанию 3. Не поддерживается в
                                        ESQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>TIMESTAMP</para>
            </formalpara>

            <para>Переменная LOCALTIMESTAMP возвращает текущую дату и время сервера. Точность
                определяет, сколько учитывать знаков после запятой в долях секунды. Точность по
                умолчанию равна 3.</para>
            <note>
                <para>В блоке кода PSQL (процедура, триггер, исполняемый блок) значение
                    LOCALTIMESTAMP не меняется по мере выполнения. При вызове вложенного кода,
                    значение также не изменится и будет равно значению в коде самого верхнего
                    уровня. Для определения реального времени используйте другие переменные,
                    например 'NOW' (с полным приведением типа данных). </para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной LOCALTIMESTAMP</title>
                        <para><programlisting language="sql">
SELECT LOCALTIMESTAMP(2) FROM RDB$DATABASE;
-- результат будет (например) 02.03.2014 23:35:33.1200            
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <warning>
                <para>Firebird 4.0 будет поддерживать часовые пояса.</para>
                <para>В рамках этой поддержки будет возникать несовместимость с выражением
                        <code>CURRENT_TIMESTAMP</code> предыдущих версий.</para>
                <para>В Firebird 4.0 выражение <code>CURRENT_TIMESTAMP</code> будет возвращать тип
                    данных <code>TIMESTAMP WITH TIME ZONE</code>.</para>
                <para>Для того чтобы ваши запросы были совместимы с кодом баз данных будующих
                    версий, начиная с Firebird 3.0.4 вы можете использовать выражение
                        <code>LOCALTIMESTAMP</code>. В 3.0 <code>LOCALTIMESTAMP</code> является
                    синонимом <code>CURRENT_TIMESTAMP</code>.</para>
                <para>В Firebird 4.0 <code>LOCALTIMESTAMP</code> будет продолжать работать точно так
                    же как сейчас, в то время как <code>CURRENT_TIMESTAMP</code> будет возвращать
                    другой тип данных.</para>

                <para>Вам не следует начинать использовать <code>LOCALTIMESTAMP</code>, если можете
                    произвести даунгрейд вашей базы данных до версии 3.0.3 или другой более младшей
                    версии, поскольку старые версии Firebird не смогут распознать новые
                    выражения.</para>
            </warning>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_timestamp"
                        >CURRENT_TIMESTAMP</link>, <link linkend="internalfunc-contextvar-now"
                        >'NOW'</link>, <link linkend="internalfunc-contextvar-current_time"
                        >CURRENT_TIME</link>, <link linkend="internalfunc-contextvar-current_date"
                        >CURRENT_DATE</link>. </para>
            </formalpara>
        </section>

        <section xml:id="internalfunc-contextvar-new">
            <info>
                <title>NEW</title>
                <keywordset>
                    <keyword>NEW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>NEW</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
NEW                     
                    </programlisting>
                </para>
            </formalpara>

            <para>Контекстная переменная NEW доступна только в коде табличных триггеров. Значение
                NEW содержит новые значения полей данных, которое возникли в базе во время операции
                обновления или вставки.</para>
            <para>В AFTER триггерах переменная доступна только для чтения.</para>
            <note>
                <para>Для табличных триггеров, срабатывающих на несколько типов событий, переменная
                    NEW доступна всегда. Однако в случае если триггер сработал на операцию удаления,
                    то для него новая версия данных не имеет смысла. В этой ситуации чтение
                    переменной NEW всегда вернёт NULL.</para>
            </note>
            <important>
                <para>Попытка записи в переменную NEW в AFTER триггере вызовет исключение в коде.
                </para>
            </important>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной NEW</title>
                        <para><programlisting language="sql">
...
  IF (NEW.SERIAL_NUM IS NULL) THEN
    NEW.SERIAL_NUM = GEN_ID (GEN_SERIALS, 1);
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-old">OLD</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-now">
            <info>
                <title>'NOW'</title>
                <keywordset>
                    <keyword>'NOW'</keyword>
                </keywordset>
            </info>
            <indexterm><primary>NOW</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
'NOW'                    
                    </programlisting>
                </para>
            </formalpara>

            <para>Не является переменной, а является строковым литералом. При использовании
                преобразования типов данных, например, с помощью функции CAST() в тип даты/времени
                позволяет получить текущую дату и/или время. Значение &quot;после запятой&quot; у
                переменной показывают число миллисекунд. Точность составляет 3 знака после запятой
                (миллисекунды). Написание 'NOW' не зависит от регистра, при преобразовании в дату
                функция игнорирует все пробелы слева и справа от слова.</para>
            <note>
                <para>Поскольку 'NOW' всегда возвращает актуальные значения даты и времени при
                    использовании CAST() для приведения типов данных она может использоваться для
                    измерения временных интервалов и скорости выполнения кода в процедурах,
                    триггерах и блоках кода PSQL.</para>
            </note>


            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной 'NOW'</title>
                        <para><programlisting language="sql">
SELECT CAST('Now' AS DATE) FROM rdb$database;
-- возвратит текущую дату, например 2014-10-03

SELECT CAST('now' AS TIME) FROM rdb$database;
-- возвратит текущее время, например 14:20:19.6170

SELECT CAST('NOW' AS TIMESTAMP) FROM rdb$database;
-- возвратит текущую дату и время, например 2014-10-03 14:20:19.6170

-- при использовании короткого "C-Style" литерала
-- будет возращено дата и время на момент подготовки запроса
SELECT TIMESTAMP 'NOW' FROM rdb$database; 
                </programlisting></para>
                    </example>
                    <example>
                        <title>Использование 'NOW' измерения длительности выполнения кода</title>
                        <para><programlisting language="sql">
<![CDATA[
EXECUTE BLOCK
RETURNS (ms BIGINT)
AS
DECLARE VARIABLE t1 TIME;
DECLARE VARIABLE n BIGINT;
BEGIN
  t1 = CAST('now' AS TIME);
  /* Долгая операция  */
  SELECT COUNT(*) FROM rdb$types, rdb$types, rdb$types INTO n;
  /*======*/
  ms = DATEDIFF(MILLISECOND FROM t1 TO CAST('now' AS TIME));
  SUSPEND;
END
]]> 
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <warning>
                <para>Не рекомендуем использовать сокращённые выражения для литерала 'NOW'.
                    Использование таких выражений в компилируемом PSQL приводит к тому, что значение
                    "замораживается" на момент компиляции, и в результате возвращается не актуальное
                    значение. В Firebird 4.0 сокращённые выражения для таких строковых литералов
                    будут запрещены, однако вы по прежнему сможете использовать их при приведении
                    типа оператором CAST. Смотри также <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" linkend="types-datetime-literals"
                        >Литералы даты и времени</link>.</para>
            </warning>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_timestamp"
                        >CURRENT_TIMESTAMP</link>, <link
                        linkend="internalfunc-contextvar-current_date">CURRENT_DATE</link>, <link
                        linkend="internalfunc-contextvar-current_time">CURRENT_TIME</link>, <link
                        linkend="internalfunc-contextvar-today">TODAY</link>, <link
                        linkend="internalfunc-contextvar-tomorrow">TOMORROW</link>, <link
                        linkend="internalfunc-contextvar-yesterday">YESTERDAY</link>, <link
                        linkend="types-cast-dateliteral">Преобразование строк в дату и время</link>.
                </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-old">
            <info>
                <title>OLD</title>
                <keywordset>
                    <keyword>OLD</keyword>
                </keywordset>
            </info>
            <indexterm><primary>OLD</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
OLD                     
                    </programlisting>
                </para>
            </formalpara>

            <para>Контекстная переменная OLD доступна только коде триггеров. Значения, содержащееся
                в OLD, хранит прошлые значения полей, которые были в базе до операции изменения или
                удаления.</para>
            <para>Переменная OLD доступна только для чтения.</para>
            <note>
                <para>Для табличных триггеров, срабатывающих на несколько типов событий, значения
                    для переменной OLD всегда возможны. Однако для триггеров, сработавших на вставку
                    записи, значение данной переменной не имеет смысла, поэтому в этой ситуации
                    чтение OLD возвратит NULL, а попытка записи в неё вызовет исключение в
                    коде.</para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной OLD</title>
                        <para><programlisting language="sql">
...
  IF (NEW.QUANTITY IS DISTINCT FROM OLD.QUANTITY) THEN
    DELTA = NEW.QUANTITY - OLD.QUANTITY;
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-new">NEW</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-row_count">
            <info>
                <title>ROW_COUNT</title>
                <keywordset>
                    <keyword>ROW_COUNT</keyword>
                </keywordset>
            </info>

            <indexterm><primary>ROW_COUNT</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
ROW_COUNT                     
                    </programlisting>
                </para>
            </formalpara>

            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>INTEGER</para>
            </formalpara>

            <para>Контекстная переменная ROW_COUNT содержит число строк, затронутых последним
                оператором DML (INSERT, UPDATE, DELETE, SELECT или FETCH) в текущем триггере,
                хранимой процедуре или исполняемом блоке.</para>
            <para>Поведение с SELECT и FETCH: <itemizedlist spacing="compact">
                    <listitem>
                        <para>После выполнения singleton SELECT запроса (запроса, который может
                            вернуть не более одной строки данных), ROW_COUNT равна 1, если была
                            получена строка данных и 0 в противном случае;</para>
                    </listitem>
                    <listitem>
                        <para>В цикле <link linkend="psql-statements-forselect">FOR SELECT</link>
                            переменная ROW_COUNT увеличивается на каждой итерации (начиная с 0 в
                            качестве первого значения);</para>
                    </listitem>
                    <listitem>
                        <para>После выборки (FETCH) из курсора, ROW_COUNT равна 1, если была
                            получена строка данных и 0 в противном случае. Выборка нескольких
                            записей из одного курсора не увеличивает ROW_COUNT после 1.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <important>
                <para>Переменная ROW_COUNT не может быть использована для определения количества
                    строк, затронутых при выполнении операторов EXECUTE STATEMENT или EXECUTE
                    PROCEDURE. Для оператора MERGE переменная ROW_COUNT будет содержать 0 или 1,
                    даже если было затронуто более записей </para>
            </important>
            <warning>
                <para>Не используйте переменную ROW_COUNT внутри DML операторов. Дело в том, что эта
                    переменная сбрасывает своё значение в 0 перед началом выполнения любого DML
                    оператора, а потому вы можете получить не то что ожидаете.
                    <programlisting language="sql">
...                        
UPDATE t2 SET 
    evt='upd', 
    old_id = old.id, old_x = old.x, 
    new_id = new.id, new_x = new.x
WHERE new_id = old.id;

INSERT INTO t2log(evt, affected_rows) VALUES('upd', ROW_COUNT); 
...
                    </programlisting>
                    В вышеприведённом примере в столбец affected_rows будут записаны нулевые
                    значения, даже если оператором UPDATE были затронуты строки. Для того, чтобы
                    исправить эту ошибку, необходимо сохранить значение контекстной переменной
                    ROW_COUNT в локальную переменную PSQL модуля и использовать эту локальную
                    переменную в DML операторе.
                    <programlisting language="sql">
...                        
DECLARE rc INT;                        
...                        
UPDATE t2 SET 
    evt='upd', 
    old_id = old.id, old_x = old.x, 
    new_id = new.id, new_x = new.x
WHERE new_id = old.id;

rc = ROW_COUNT;
INSERT INTO t2log(evt, affected_rows) VALUES('upd', rc); 
...
                    </programlisting>
                </para>
            </warning>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной ROW_COUNT</title>
                        <para><programlisting language="sql">
...
UPDATE Figures SET Number = 0 WHERE id = :id;
IF (row_count = 0) THEN
  INSERT INTO Figures (id, Number) 
  VALUES (:id, 0);
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-sqlcode">
            <info>
                <title>SQLCODE</title>
                <keywordset>
                    <keyword>SQLCODE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>SQLCODE</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SQLCODE                      
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>INTEGER</para>
            </formalpara>

            <para>В блоках обработки ошибок &quot;WHEN ... DO&quot; контекстная переменная SQLCODE
                содержит текущий код ошибки SQL. До Firebird 2.0 значение SQLCODE можно было
                получить только в блоках обработки ошибок WHEN SQLCODE и WHEN ANY. Теперь она может
                быть отлична от нуля в блоках WHEN GDSCODE и WHEN EXCEPTION при условии, что ошибка,
                вызвавшее срабатывание блока, соответствует коду ошибки SQL. Вне обработчиков ошибок
                SQLCODE всегда равен 0, а вне PSQL не существует вообще.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной SQLCODE</title>
                        <para><programlisting language="sql">
...
WHEN ANY DO
BEGIN
  IF (SQLCODE &lt;&gt; 0) THEN
    MSG = 'Обнаружена ошибка SQL!';
  ELSE
    MSG = 'Ошибки нет!';
  EXCEPTION EX_CUSTOM MSG;
END
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-gdscode">GDSCODE</link>, <link
                        linkend="internalfunc-contextvar-sqlstate">SQLSTATE</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-sqlstate">
            <info>
                <title>SQLSTATE</title>
                <keywordset>
                    <keyword>SQLSTATE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>SQLSTATE</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SQLSTATE                      
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>CHAR(5)</para>
            </formalpara>

            <para>В блоках обработки ошибок &quot;WHEN ... DO&quot; контекстная переменная SQLSTATE
                переменная содержит 5 символов SQL-2003 — совместимого кода состояния, переданного
                оператором, вызвавшим ошибку. Вне обработчиков ошибок SQLSTATE всегда равен '00000',
                а вне PSQL не существует вообще.</para>
            <note>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>SQLSTATE предназначен для замены SQLCODE. Последняя, в настоящее
                                время устарела и буден удалена будущих версиях Firebird;</para>
                        </listitem>
                        <listitem>
                            <para>Любой код SQLSTATE состоит из двух символов класса и трёх символов
                                подкласса. Класс 00 (успешное выполнение), 01 (предупреждение) и 02
                                (нет данных) представляют собой условия завершения. Каждый код
                                статуса вне этих классов является исключением. Поскольку классы 00,
                                01 и 02 не вызывают ошибку, они никогда не будут обнаруживаться в
                                переменной SQLSTATE.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной SQLSTATE</title>
                        <para><programlisting language="sql">
WHEN ANY DO
BEGIN
  MSG = CASE SQLSTATE
          WHEN '22003' THEN
            'Число вышло за пределы диапазона!'
          WHEN '22012' THEN
            'Деление на ноль!'
          WHEN '23000' THEN
            'Нарушение ограничения целостности!'
          ELSE 'Ошибок нет! SQLSTATE = ' || SQLSTATE;
        END;
  EXCEPTION EX_CUSTOM MSG;
END
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-gdscode">GDSCODE</link>, <link
                        linkend="internalfunc-contextvar-sqlcode">SQLCODE</link>, <link
                        linkend="error">Коды ошибок SQLSTATE и их описание</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-today">
            <info>
                <title>'TODAY'</title>
                <keywordset>
                    <keyword>'TODAY'</keyword>
                </keywordset>
            </info>

            <indexterm><primary>TODAY</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
'TODAY'                    
                    </programlisting>
                </para>
            </formalpara>

            <para>Не является переменной, а является строковым литералом. При использовании
                преобразования типов данных, например, с помощью функции CAST() в тип даты/времени
                позволяет получить текущую дату. Написание 'TODAY' не зависит от регистра, при
                преобразовании в дату функция игнорирует все пробелы слева и справа от слова.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной 'TODAY'</title>
                        <para><programlisting language="sql">
SELECT CAST('Today' AS DATE) FROM rdb$database;
-- возвратит дату на сегодня, например 2014-10-03
SELECT CAST('TODAY' AS TIMESTAMP) FROM rdb$database;
-- возвратит дату на сегодня, например 2014-10-03 00:00:00.0000
 
-- при использовании короткого "C-Style" литерала
-- будет возращена дата подготовки запроса
SELECT DATE 'TODAY' FROM rdb$database; 
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <warning>
                <para>Не рекомендуем использовать сокращённые выражения для литерала 'TODAY'.
                    Использование таких выражений в компилируемом PSQL приводит к тому, что значение
                    "замораживается" на момент компиляции, и в результате возвращается не актуальное
                    значение. В Firebird 4.0 сокращённые выражения для таких строковых литералов
                    будут запрещены, однако вы по прежнему сможете использовать их при приведении
                    типа оператором CAST. Смотри также <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" linkend="types-datetime-literals"
                        >Литералы даты и времени</link>.</para>
            </warning>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_date">CURRENT_DATE</link>, <link
                        linkend="internalfunc-contextvar-tomorrow">TOMORROW</link>, <link
                        linkend="internalfunc-contextvar-yesterday">YESTERDAY</link>, <link
                        linkend="types-cast-dateliteral">Преобразование строк в дату и время</link>.
                </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-tomorrow">
            <info>
                <title>'TOMORROW'</title>
                <keywordset>
                    <keyword>'TOMORROW'</keyword>
                </keywordset>
            </info>

            <indexterm><primary>TOMORROW</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
'TOMORROW'                    
                    </programlisting>
                </para>
            </formalpara>

            <para>Не является переменной, а является строковым литералом. При использовании
                преобразования, например, с помощью функции CAST() в тип даты / времени позволяет
                получить дату, следующую за текущей. Написание 'TOMORROW' не зависит от регистра,
                при преобразовании в дату функция игнорирует все пробелы слева и справа от
                слова.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной 'TOMORROW'</title>
                        <para><programlisting language="sql">
SELECT CAST('Tomorrow' AS DATE) FROM rdb$database;
-- будет возращена завтрашняя дата, например 2014-10-04

SELECT CAST('TOMORROW' AS TIMESTAMP) FROM rdb$database;
-- будет возращена завтрашняя дата, например 2014-10-04 00:00:00.0000

-- при использовании короткого "C-Style" литерала
-- будет возращена дата на 1 день больше даты подготовки запроса
SELECT DATE 'Tomorrow' FROM rdb$database;
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <warning>
                <para>Не рекомендуем использовать сокращённые выражения для литерала 'TOMORROW'.
                    Использование таких выражений в компилируемом PSQL приводит к тому, что значение
                    "замораживается" на момент компиляции, и в результате возвращается не актуальное
                    значение. В Firebird 4.0 сокращённые выражения для таких строковых литералов
                    будут запрещены, однако вы по прежнему сможете использовать их при приведении
                    типа оператором CAST. Смотри также <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" linkend="types-datetime-literals"
                        >Литералы даты и времени</link>.</para>
            </warning>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_date">CURRENT_DATE</link>, <link
                        linkend="internalfunc-contextvar-today">TODAY</link>, <link
                        linkend="internalfunc-contextvar-yesterday">YESTERDAY</link>, <link
                        linkend="types-cast-dateliteral">Преобразование строк в дату и время</link>.
                </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-updating">
            <info>
                <title>UPDATING</title>
                <keywordset>
                    <keyword>UPDATING</keyword>
                </keywordset>
            </info>

            <indexterm><primary>UPDATING</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
UPDATING                     
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>BOOLEAN</para>
            </formalpara>

            <para>Контекстная переменная UPDATING доступна только коде табличных триггеров.
                Используется в триггерах на несколько типов событий и показывает, что триггер
                сработал при выполнении операции UPDATE. </para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной UPDATING</title>
                        <para><programlisting language="sql">
...
IF (INSERTING OR UPDATING) THEN
BEGIN
  IF (NEW.SERIAL_NUM IS NULL) THEN
    NEW.SERIAL_NUM = GEN_ID (GEN_SERIALS, 1);
END
...
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-inserting">INSERTING</link>, <link
                        linkend="internalfunc-contextvar-deleting">DELETING</link>. </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-yesterday">
            <info>
                <title>'YERSTERDAY'</title>
                <keywordset>
                    <keyword>'YERSTERDAY'</keyword>
                </keywordset>
            </info>

            <indexterm><primary>YERSTERDAY</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
'YERSTERDAY'                    
                    </programlisting>
                </para>
            </formalpara>

            <para>Не является переменной, а является строковым литералом. При использовании
                преобразования, например, с помощью функции CAST() в тип даты / времени позволяет
                получить дату, предыдущую перед текущей. Написание 'YERSTERDAY' не зависит от
                регистра, при преобразовании в дату функция игнорирует все пробелы слева и справа от
                слова.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной 'YERSTERDAY'</title>
                        <para><programlisting language="sql">
SELECT CAST('Yesterday' AS DATE) FROM rdb$database;
-- будет возращена вчерашняя дата, например 2014-10-04

-- использовании короткого "C-Style" литерала
-- будет возращена дата 1 день меньше даты подготовки запроса
SELECT DATE 'Yesterday' FROM rdb$database;
SELECT TIMESTAMP 'YESTERDAY' FROM rdb$database;
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <warning>
                <para>Не рекомендуем использовать сокращённые выражения для литерала 'YESTERDAY'.
                    Использование таких выражений в компилируемом PSQL приводит к тому, что значение
                    "замораживается" на момент компиляции, и в результате возвращается не актуальное
                    значение. В Firebird 4.0 сокращённые выражения для таких строковых литералов
                    будут запрещены, однако вы по прежнему сможете использовать их при приведении
                    типа оператором CAST. Смотри также <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" linkend="types-datetime-literals"
                        >Литералы даты и времени</link>.</para>
            </warning>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_date">CURRENT_DATE</link>, <link
                        linkend="internalfunc-contextvar-today">TODAY</link>, <link
                        linkend="internalfunc-contextvar-tomorrow">TOMORROW</link>, <link
                        linkend="types-cast-dateliteral">Преобразование строк в дату и время</link>.
                </para>
            </formalpara>
        </section>
        <section xml:id="internalfunc-contextvar-user">
            <info>
                <title>USER</title>
                <keywordset>
                    <keyword>USER</keyword>
                </keywordset>
            </info>

            <indexterm><primary>USER</primary></indexterm>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
USER                      
                        </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Тип возвращаемого результата:</title>
                <para>VARCHAR(31)</para>
            </formalpara>

            <para>Переменная USER содержит имя текущего подключенного пользователя базы данных. </para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование переменной USER</title>
                        <para><programlisting language="sql">
NEW.ADDED_BY = USER;
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-contextvar-current_user">CURRENT_USER</link>, <link
                        linkend="internalfunc-contextvar-current_role">CURRENT_ROLE</link>. </para>
            </formalpara>
        </section>

   
</chapter>

